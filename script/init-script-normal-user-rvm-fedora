#!/bin/bash
#
# init script build as PoC for
# 1) normal user (non root)
# 2) rvm support
# 3) pid files in user space
# 4) fedora os

# source function library
. /etc/rc.d/init.d/functions

# Get network config
. /etc/sysconfig/network

[ "${NETWORKING}" = "no" ] && exit 0

DAEMON_HOME=/home/kraftvoll/zammad/
#RAILS_ENV=production
RAILS_ENV=test
NAME=zammad
APP_PORT=3000
WS_PORT=6042

ZAMMAD_CONFIG=/etc/sysconfig/zammad
# Read config   
[ -f "$JENKINS_CONFIG" ] && . "$JENKINS_CONFIG"


# Load RVM into a shell session *as a function*
if [[ -s "$HOME/.rvm/scripts/rvm" ]] ; then
    # First try to load from a user install
    source "$HOME/.rvm/scripts/rvm"
elif [[ -s "/usr/local/rvm/scripts/rvm" ]] ; then
    # Then try to load from a root install
    source "/usr/local/rvm/scripts/rvm"
else
    printf "ERROR: An RVM installation was not found.\n"
    exit 1
fi

rvm use ruby-1.9.3-p286

RUBY=$(which ruby)
RAILS=$(which rails)
BUNDLE=$(which rails)

APP_PIDFILE=$DAEMON_HOME/tmp/pids/server.pid
WS_PIDFILE=$DAEMON_HOME/tmp/pids/websocket.pid
WORKER_PIDFILE=$DAEMON_HOME/tmp/pids/sessionworker.pid

start() {

    cd $DAEMON_HOME

    # precompile assets
    if [ "$RAILS_ENV" = "production" ]; then
        echo -n $"Precompile assets for ${NAME}/${RAILS_ENV}"
        $BUNDLE exec rake assets:precompile && echo_success || echo_failure
        echo
    fi

    # start web server
    echo -n $"Starting ${NAME}/${RAILS_ENV} application server on port: ${APP_PORT}"
    $RAILS server -d -p $APP_PORT --pid $APP_PIDFILE &> /dev/null
    sleep 2
    status -p $APP_PIDFILE &> /dev/null && echo_success || echo_failure
    echo

    # start websocket server
    echo -n $"Starting ${NAME}/${RAILS_ENV} web socket server on port: ${WS_PORT}"
    nohup $RUBY script/websocket-server.rb -p $WS_PORT -i $WS_PIDFILE &> /dev/null &
    sleep 2
    status -p $WS_PIDFILE &> /dev/null && echo_success || echo_failure
    echo

    # start session worker
    echo -n $"Starting ${NAME}/${RAILS_ENV} session worker"
    nohup $RAILS runner 'Session.jobs' &> /dev/null &
    sleep 10
    status -p $WORKER_PIDFILE &> /dev/null && echo_success || echo_failure
    echo
}

stop() {
    # stop session worker
    echo -n $"Shutting down ${NAME}/${RAILS_ENV} session worker"
    if test -e $WORKER_PIDFILE; then
        killproc -p $WORKER_PIDFILE
    fi
    echo

    # stop websocket server
    echo -n $"Shutting down ${NAME}/${RAILS_ENV} web socket server on port: ${WS_PORT}"
    if test -e $WS_PIDFILE; then
        killproc -p $WS_PIDFILE
    fi
    echo

    # stop web server
    echo -n $"Shutting down ${NAME}/${RAILS_ENV} application server on port: ${APP_PORT}"
    if test -e $APP_PIDFILE; then
        killproc -p $APP_PIDFILE
    fi
    echo

}

case "$1" in
    start)
        start
    ;;
    stop)
        stop
    ;;
    restart)
        stop
        start
    ;;
    status)
        status -p $APP_PIDFILE "${NAME} ${RAILS_ENV} - application server"
        status -p $WS_PIDFILE "${NAME} ${RAILS_ENV} - web socket server"
        status -p $WORKER_PIDFILE "${NAME} ${RAILS_ENV} - session worker"
    ;;

    *)
        echo "Usage: $SCRIPTNAME {start|stop|restart|status}" >&2
        exit 3
    ;;
esac

